---
title: "Defensive functions assignment"
author: "Marie Mortensen"
date: "10/25/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading packages and data
```{r libraries, echo = FALSE}
pacman::p_load(tidyverse, gganimate, gapminder, readr)
```

Checking that I have the data
```{r}
unique(gapminder$year)
head(gapminder)
```

Define a defensive function that calculates the Gross Domestic Product of a nation from the data available in the gapminder dataset. Using that function, calculate the GDP of Denmark in the following years: 1967, 1977, 1987, 1997, 2007, and 2017.
```{r}
options(scipen =1000)
#Right now we only have GDP per capita which is defined by the GDP divided by the population. Therefore, we must first multiply the GDP per capita with the population. 
#By using colnames() we can see the names of the gdp per capita function and the population column. They are called gdpPercap and pop, respectively.
colnames(gapminder)

#first i try to write out how to calculate gdp before using existing functions before making it a function myself. In this example I'm using pipes, mutate and filter from the tidyverse package. Using mutate, a new column called GDP is added to the dataframe and it contains the information from gdpPercap multiplied by the information in the population column. Afterwards, I extract information only from a specific year using filter.
gapminder <- gapminder %>% mutate(GDP = (gdpPercap*pop))
gapminder %>% filter(year == 1967, country == "Denmark")

#That seemed to work. Now I will try to make it a function where input is the dataframe, the column with gdp per capita and the population column and lastly a preferred year. 
gdp_func <- function(dataframe, 
                     per_cap_col, 
                     population_col, 
                     country_name, 
                     year_no){

if(!is.numeric(per_cap_col)){
  stop("the per capita column must be numeric")
}
if(!is.numeric(population_col)){
   stop("the population column must be numeric")
}
if(!is.numeric(year_no)){
   stop("year must be numeric")
}
GDP_df <- dataframe %>% 
  mutate(GDP = per_cap_col*population_co) %>% 
  filter(year == year_no) %>% filter(country == country_name) %>% 
  select(country, year, GDP)

return(GDP_df)
}

gdp_func(dataframe = gapminder, per_cap_col = gapminder$gdpPercap, 
                     population_col = gapminder$pop, 
                     country_name = "Denmark", 
                     year_no = 1967)
gdp_func(dataframe = gapminder, per_cap_col = gapminder$gdpPercap, 
                     population_col = gapminder$pop, 
                     country_name = "Denmark", 
                     year_no = 1977)
gdp_func(dataframe = gapminder, per_cap_col = gapminder$gdpPercap, 
                     population_col = gapminder$pop, 
                     country_name = "Denmark", 
                     year_no = 1987)
gdp_func(dataframe = gapminder, per_cap_col = gapminder$gdpPercap, 
                     population_col = gapminder$pop, 
                     country_name = "Denmark", 
                     year_no = 1997)
gdp_func(dataframe = gapminder, per_cap_col = gapminder$gdpPercap, 
                     population_col = gapminder$pop, 
                     country_name = "Denmark", 
                     year_no = 2007)
gdp_func(dataframe = gapminder, per_cap_col = gapminder$gdpPercap, 
                     population_col = gapminder$pop, 
                     country_name = "Denmark", 
                     year_no = 2017)
```

Write a script that loops over each country in the gapminder dataset, tests whether the country starts with a ‘B’ , and print out whether the life expectancy is smaller than 50, between 50 and 70, or greater than 70.

```{r}
#firstly, I save the first letter of the country column in a new column using the str_match from the stringr package and mutate. Afterwards, I'm saving every row (i) of the column lifeExp in a list called exp and afterwards I make it print everytime it meets any of the conditions (being below 50, between 50 and 70 or greater than 70).

gapminder <- gapminder %>% 
  mutate(first_letter = stringr::str_match(country,
 ".{1}"))

for(i in 1:nrow(gapminder[gapminder$first_letter=="B",])){ #for every row where country starts with "B" 
 exp <- gapminder$lifeExp[gapminder$first_letter=="B"] #save every row in the column lifeExp for country that starts with "B" 
  if(exp[i]<50){ #if it is below 50 print
    print("Life expectancy below 50")
  }
   if(exp[i]>70){ #if it is greater than 70 print
    print("Life expectancy above 70")
   }
  if(exp[i]>50 & exp[i]<70){ #if it is between 50 and 70
    print("Life expectancy is between 50 and 70")
  }
}
```


